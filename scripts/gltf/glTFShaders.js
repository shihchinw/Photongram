THREE.glTFShaders=function(){var e=[];return{add:function(t){e.push(t)},remove:function(t){var r=e.indexOf(t);-1!==r&&e.splice(r,1)},removeAll:function(t){e=[]},bindShaderParameters:function(t){for(i=0;i<e.length;i++)e[i].bindParameters(t)},update:function(t,r){for(i=0;i<e.length;i++)e[i].update(t,r)}}}(),THREE.glTFShader=function(e,t,r,i){this.material=e,this.parameters=t.technique.parameters,this.uniforms=t.technique.uniforms,this.joints=t.joints,this.object=r,this.semantics={},this.m4=new THREE.Matrix4},THREE.glTFShader.prototype.bindParameters=function(e){function t(e,t){e.glTFID==a.node&&(t.sourceObject=e)}for(var r in this.uniforms){var i=this.uniforms[r],a=this.parameters[i];if(a.semantic){var n={semantic:a.semantic,uniform:this.material.uniforms[r]};a.node?e.traverse(function(e){t(e,n)}):n.sourceObject=this.object,this.semantics[i]=n}}},THREE.glTFShader.prototype.update=function(e,t){e.updateMatrixWorld(),t.updateMatrixWorld(),t.matrixWorldInverse.getInverse(t.matrixWorld);for(var r in this.semantics){var i=this.semantics[r];if(i)switch(i.semantic){case"MODELVIEW":var a=i.uniform.value;a.multiplyMatrices(t.matrixWorldInverse,i.sourceObject.matrixWorld);break;case"MODELVIEWINVERSETRANSPOSE":var n=i.uniform.value;this.m4.multiplyMatrices(t.matrixWorldInverse,i.sourceObject.matrixWorld),n.getNormalMatrix(this.m4);break;case"PROJECTION":var a=i.uniform.value;a.copy(t.projectionMatrix);break;case"JOINTMATRIX":for(var s=i.uniform.value,o=0;o<s.length;o++)s[o].getInverse(i.sourceObject.matrixWorld).multiply(this.joints[o].matrixWorld).multiply(this.object.skeleton.boneInverses[o]);break;default:throw new Error("Unhandled shader semantic"+i)}}};